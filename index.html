<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Zombie Survival 3D — Forest Mode (Improved)</title>
  <style>
    html, body { height: 100%; margin: 0; background:#6fb2ff; overflow:hidden; touch-action:none; }
    #hud { position:fixed; inset:0; pointer-events:auto; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color:#fff; z-index:2; }
    #start { z-index:3; }
    #topbar { position:absolute; top:10px; left:12px; right:12px; display:flex; justify-content:space-between; align-items:center; gap:16px; }
    .panel { background:rgba(0,0,0,.35); backdrop-filter: blur(4px); padding:8px 12px; border-radius:12px; box-shadow: 0 6px 18px rgba(0,0,0,.25); }
    #healthBar { width:240px; height:14px; background: rgba(255,255,255,.2); border-radius:999px; overflow:hidden; }
    #healthFill { height:100%; width:100%; background: linear-gradient(90deg,#4efb8a,#ffcb2e,#ff5b5b); transform-origin:left center; }
    #score, #weapon { font-weight:700; letter-spacing:.5px; }
    #weapon { margin-left:8px; }
    #crosshair { position:absolute; top:50%; left:50%; width:18px; height:18px; transform:translate(-50%,-50%); pointer-events:none; opacity:.85; transition: transform 0.1s ease-out; }
    #crosshair.recoiling { transform: translate(-50%, -50%) scale(1.6); }
    #crosshair::before, #crosshair::after { content:""; position:absolute; left:50%; top:50%; background:white; border-radius:1px; opacity:.9; }
    #crosshair::before { width:16px; height:2px; transform:translate(-50%,-50%); }
    #crosshair::after  { width:2px; height:16px; transform:translate(-50%,-50%); }
    #centerFlash { position:absolute; inset:0; background:radial-gradient(40px 40px at 50% 50%, rgba(255,255,255,.75), transparent 60%); opacity:0; transition:opacity .08s; pointer-events:none; }
    #banner { position:absolute; left:50%; top:14%; transform:translateX(-50%); background:rgba(0,0,0,.55); padding:8px 14px; border-radius:12px; font-weight:700; opacity:0; transition:opacity .3s, transform .3s; pointer-events:none; }
    #banner.show { opacity:1; transform:translateX(-50%) translateY(-6px); }

    #start { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:linear-gradient(180deg, rgba(0,0,0,.55), rgba(0,0,0,.35)); text-align:center; }
    #start .card { pointer-events:auto; width:min(640px,94vw); background:rgba(0,0,0,.55); padding:24px 22px; border-radius:16px; box-shadow:0 10px 40px rgba(0,0,0,.45); }
    #start h1 { margin:0 0 10px; font-size:28px; }
    #start p { margin:8px 0; line-height:1.5; color:#eaeaea; }
    #start ul { margin:8px 0 0 18px; text-align:left; }
    #start button { margin-top:12px; padding:12px 18px; border:0; border-radius:12px; background:#16a34a; color:#fff; font-weight:700; letter-spacing:.3px; cursor:pointer; }
    #start kbd { background:#111; padding:4px 8px; border-radius:6px; border:1px solid #333; font-weight:700; }

    #gameover { position:absolute; inset:0; display:none; align-items:center; justify-content:center; background:linear-gradient(180deg, rgba(0,0,0,.6), rgba(0,0,0,.35)); text-align:center; }
    #gameover .card { pointer-events:auto; width:min(520px,92vw); background:rgba(0,0,0,.6); padding:24px 22px; border-radius:16px; box-shadow:0 10px 40px rgba(0,0,0,.45); }
    #gameover h2 { margin:0 0 10px; font-size:26px; }
    #gameover button { margin-top:12px; padding:12px 18px; border:0; border-radius:12px; background:#2563eb; color:#fff; font-weight:700; letter-spacing:.3px; cursor:pointer; }

    /* Mobile controls */
    #mobileUI { position:absolute; inset:0; display:none; pointer-events:none; }
    @media (pointer: coarse) { #mobileUI { display:block; } }
    .joy { position:absolute; bottom:12vh; width:44vw; max-width:260px; height:44vw; max-height:260px; border-radius:50%; border:2px solid rgba(255,255,255,.25); background:rgba(0,0,0,.2); box-shadow: inset 0 0 0 2px rgba(255,255,255,.1); pointer-events:auto; touch-action:none; }
    #joyL { left:4vw; }
    .stick { position:absolute; left:50%; top:50%; width:34%; height:34%; transform:translate(-50%,-50%); border-radius:50%; background:rgba(255,255,255,.35); box-shadow:0 4px 10px rgba(0,0,0,.3); }
    .aimpad { position:absolute; right:4vw; bottom:10vh; width:48vw; max-width:320px; height:48vw; max-height:320px; border-radius:16px; border:2px solid rgba(255,255,255,.25); background:rgba(0,0,0,.2); pointer-events:auto; touch-action:none; }
    .btn { position:absolute; pointer-events:auto; touch-action:none; border-radius:999px; border:0; color:#fff; font-weight:800; letter-spacing:.5px; box-shadow:0 6px 20px rgba(0,0,0,.4); }
    #btnFire { right:6vw; bottom:22vh; width:86px; height:86px; background:#ef4444; }
    #btnFire.on { outline:4px solid rgba(255,255,255,.3); }
    #btnPickup { right:6vw; bottom:10vh; width:64px; height:64px; background:#22c55e; }
    #btnSprint { left:6vw; bottom:24vh; width:72px; height:72px; background:#0ea5e9; }
    #btnSprint.on { outline:4px solid rgba(255,255,255,.3); }
    #mobileHint { display:none; position:absolute; bottom:10px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,.5); padding:8px 12px; border-radius:999px; font-size:13px; }
    @media (pointer: coarse) { #mobileHint { display:block; } }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="hud">
    <div id="topbar">
      <div class="panel" style="display:flex; align-items:center; gap:10px;">
        <div id="healthBar"><div id="healthFill"></div></div>
        <div id="weapon">Pistol</div>
      </div>
      <div class="panel"><span id="score">Kill: 0</span></div>
    </div>
    <div id="crosshair" aria-hidden="true"></div>
    <div id="centerFlash" aria-hidden="true"></div>
    <div id="banner" aria-live="polite"></div>
    <div id="mobileHint">Di HP: gunakan joystick kiri untuk bergerak, seret panel kanan untuk lihat, tombol merah untuk menembak</div>

    <div id="start">
      <div class="card">
        <h1>Zombie Survival 3D — Forest</h1>
        <p><b>Mode bertahan hidup:</b> semakin lama, semakin banyak zombie. Cari peti senjata di hutan untuk upgrade <b>SMG</b> atau <b>Shotgun</b>.</p>
        <p><b>Kontrol Desktop:</b> <kbd>W</kbd> maju, <kbd>S</kbd> mundur, <kbd>A</kbd> kiri, <kbd>D</kbd> kanan, <kbd>Shift</kbd> lari 2×, mouse untuk lihat, klik kiri tembak, <kbd>R</kbd> ambil item.</p>
        <p><b>Kontrol HP:</b> Joystick kiri gerak, <b>seret area kanan</b> untuk lihat, tombol <b>merah</b> tembak (tahan = auto), tombol <b>hijau</b> ambil item, tombol <b>biru</b> sprint selama ditekan.</p>
        <button id="startBtn">Klik untuk Mulai</button>
      </div>
    </div>

    <div id="gameover">
      <div class="card">
        <h2>GAME OVER</h2>
        <p id="stats">Anda bertahan 0 detik · 0 kill</p>
        <button id="restartBtn">Main Lagi</button>
      </div>
    </div>

    <div id="mobileUI">
      <div id="joyL" class="joy"><div class="stick"></div></div>
      <div id="aimR" class="aimpad"></div>
      <button id="btnFire" class="btn">FIRE</button>
      <button id="btnPickup" class="btn">R</button>
      <button id="btnSprint" class="btn">RUN</button>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
  (function(){
    // === DOM ===
    const cvs = document.getElementById('game');
    const startUI = document.getElementById('start');
    const startBtn = document.getElementById('startBtn');
    const gameover = document.getElementById('gameover');
    const restartBtn = document.getElementById('restartBtn');
    const scoreEl = document.getElementById('score');
    const healthFill = document.getElementById('healthFill');
    const centerFlash = document.getElementById('centerFlash');
    const weaponEl = document.getElementById('weapon');
    const statsEl = document.getElementById('stats');
    
    // Mobile UI nodes
    const mobileUI = document.getElementById('mobileUI');
    const joyL = document.getElementById('joyL');
    const joyStick = joyL.querySelector('.stick');
    const aimR = document.getElementById('aimR');
    const btnFire = document.getElementById('btnFire');
    const btnPickup = document.getElementById('btnPickup');
    const btnSprint = document.getElementById('btnSprint');

    const isMobileLike = typeof matchMedia==='function' ? matchMedia('(pointer: coarse)').matches : false;
    let W = innerWidth, H = innerHeight;

    // === Three.js ===
    const renderer = new THREE.WebGLRenderer({ canvas: cvs, antialias:true });
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(W, H);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = true; // AKTIFKAN BAYANGAN
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Bayangan lebih halus

    const scene = new THREE.Scene();
    const SKY = 0x84c9ff;
    scene.background = new THREE.Color(SKY);
    scene.fog = new THREE.FogExp2(SKY, 0.012);

    const camera = new THREE.PerspectiveCamera(75, W/H, 0.1, 500);
    const playerHeight = 1.6; camera.position.set(0, playerHeight, 5);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8); // Sedikit ubah warna bawah
    const sun = new THREE.DirectionalLight(0xffffff, 1.0); // Cahaya lebih terang
    sun.position.set(30,50,20);
    sun.castShadow = true; // Lampu ini akan menghasilkan bayangan
    sun.shadow.mapSize.width = 2048; // Resolusi bayangan (makin tinggi makin bagus tapi berat)
    sun.shadow.mapSize.height = 2048;
    const shadowSize = 60; // Ukuran area bayangan
    sun.shadow.camera.left = -shadowSize;
    sun.shadow.camera.right = shadowSize;
    sun.shadow.camera.top = shadowSize;
    sun.shadow.camera.bottom = -shadowSize;
    scene.add(hemi, sun);
    
    // Loader untuk tekstur
    const textureLoader = new THREE.TextureLoader();
    
    // Ground dengan tekstur rumput
    const grassTexture = textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
    grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;
    grassTexture.repeat.set(100, 100); // Ulang tekstur
    
    const worldSize = 90;
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(worldSize*2, worldSize*2),
      new THREE.MeshStandardMaterial({ map: grassTexture, roughness: 1, metalness: 0 })
    );
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true; // Tanah akan menerima bayangan dari objek lain
    scene.add(ground);

    // Trees dengan tekstur kulit kayu dan variasi warna
    const barkTexture = textureLoader.load('https://threejs.org/examples/textures/terrain/tarmac_diffuse.jpg');
    barkTexture.wrapS = barkTexture.wrapT = THREE.RepeatWrapping;
    barkTexture.repeat.set(1, 4);

    const treeGroup = new THREE.Group(); scene.add(treeGroup);
    const trunkMat = new THREE.MeshStandardMaterial({ map: barkTexture, roughness: 0.9 });
    const leafMatBase = new THREE.MeshStandardMaterial({ color: 0x2f7d32, roughness: 0.8 });
    const rng = (a,b)=> a + Math.random()*(b-a);
    
    for(let i=0; i<130; i++){
      const r = rng(6, worldSize-6), ang = rng(0, Math.PI*2);
      const x = Math.cos(ang)*r, z = Math.sin(ang)*r;
      
      const leafMat = leafMatBase.clone();
      leafMat.color.setHSL(0.3 + (Math.random() - 0.5) * 0.1, 0.5, 0.25 + (Math.random() - 0.5) * 0.1);

      const trunkH = rng(1.1, 1.6);
      const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.24, trunkH, 6), trunkMat); 
      trunk.position.set(x, trunkH/2, z);
      trunk.castShadow = true;
      trunk.receiveShadow = true;

      const coneH = rng(1.6, 2.4), coneR = rng(0.9, 1.3);
      const cone = new THREE.Mesh(new THREE.ConeGeometry(coneR, coneH, 8), leafMat); 
      cone.position.set(x, trunkH/2 + coneH/2 + 0.1, z);
      cone.castShadow = true;
      cone.receiveShadow = true;
      
      treeGroup.add(trunk, cone);
    }

    // === Input / Look (NO POINTER LOCK) ===
    let state = 'idle';
    let yaw = 0, pitch = 0; // radians
    const lookSensitivity = 0.00276;
    let mouseIn = false, lastX = 0, lastY = 0;
    let mouseDown = false;
    let recoil = 0; // Variabel untuk hentakan tembakan

    const keys = { w:false, a:false, s:false, d:false, shift:false, r:false };
    function applyLookDelta(dx, dy){ yaw -= dx * lookSensitivity; pitch -= dy * lookSensitivity; const limit = Math.PI/2 - 0.02; pitch = Math.max(-limit, Math.min(limit, pitch)); }
    cvs.addEventListener('pointerenter', (e)=>{ mouseIn=true; lastX=e.clientX; lastY=e.clientY; });
    cvs.addEventListener('pointerleave', ()=>{ mouseIn=false; });
    document.addEventListener('mousemove', (e)=>{ if(state!=='playing' || !mouseIn) return; const dx = e.clientX - lastX; const dy = e.clientY - lastY; lastX = e.clientX; lastY = e.clientY; applyLookDelta(dx, dy); }, { passive:true });
    document.addEventListener('mousedown', (e)=>{ if(e.button===0){ mouseDown = true; } });
    document.addEventListener('mouseup', (e)=>{ if(e.button===0) mouseDown=false; });
    document.addEventListener('keydown', (e)=>{ switch(e.code){ case 'KeyW': keys.w=true; break; case 'KeyA': keys.a=true; break; case 'KeyS': keys.s=true; break; case 'KeyD': keys.d=true; break; case 'ShiftLeft': case 'ShiftRight': keys.shift=true; break; case 'KeyR': keys.r=true; break; } });
    document.addEventListener('keyup', (e)=>{ switch(e.code){ case 'KeyW': keys.w=false; break; case 'KeyA': keys.a=false; break; case 'KeyS': keys.s=false; break; case 'KeyD': keys.d=false; break; case 'ShiftLeft': case 'ShiftRight': keys.shift=false; break; case 'KeyR': keys.r=false; break; } });

    // === Mobile controls ===
    const joy = { active:false, id:null, cx:0, cy:0, x:0, y:0 }; const aim = { active:false, id:null, lx:0, ly:0 }; let pickupPressed = false; let sprintPressed = false;
    function joyNormalized(dx, dy, max){ const r = Math.hypot(dx,dy); if(r<=0 || !isFinite(r)) return {x:0, y:0, m:0}; const m = Math.min(1, r / Math.max(1, max)); return { x: (dx/r)*m, y: (-(dy)/r)*m, m }; }
    function handleJoy(e){ const rect = joyL.getBoundingClientRect(); const cx = rect.left + rect.width/2, cy = rect.top + rect.height/2; const dx = e.clientX - cx, dy = e.clientY - cy; const max = Math.min(rect.width, rect.height)/2 - 8; const j = joyNormalized(dx, dy, max); joy.x = j.x; joy.y = j.y; joyStick.style.transform = `translate(${(dx/Math.max(1,Math.hypot(dx,dy))) * Math.min(max, Math.hypot(dx,dy))}px, ${(dy/Math.max(1,Math.hypot(dx,dy))) * Math.min(max, Math.hypot(dx,dy))}px)`; }
    function endJoy(e){ if(!joy.active || (e && e.pointerId!==joy.id)) return; joy.active=false; joy.id=null; joy.x=0; joy.y=0; joyStick.style.transform='translate(-50%,-50%)'; try{ joyL.releasePointerCapture(e.pointerId); }catch{}}
    joyL.addEventListener('pointerdown', (e)=>{ if(!isMobileLike) return; e.preventDefault(); joy.active=true; joy.id=e.pointerId; handleJoy(e); try{ joyL.setPointerCapture(e.pointerId);}catch{} });
    joyL.addEventListener('pointermove', (e)=>{ if(!isMobileLike || !joy.active || e.pointerId!==joy.id) return; e.preventDefault(); handleJoy(e); });
    joyL.addEventListener('pointerup', endJoy); joyL.addEventListener('pointercancel', endJoy);
    aimR.addEventListener('pointerdown', (e)=>{ if(!isMobileLike) return; e.preventDefault(); aim.active=true; aim.id=e.pointerId; aim.lx=e.clientX; aim.ly=e.clientY; try{ aimR.setPointerCapture(e.pointerId);}catch{} });
    aimR.addEventListener('pointermove', (e)=>{ if(!isMobileLike || !aim.active || e.pointerId!==aim.id) return; e.preventDefault(); const dx=e.clientX-aim.lx, dy=e.clientY-aim.ly; aim.lx=e.clientX; aim.ly=e.clientY; applyLookDelta(dx, dy); });
    function endAim(e){ if(!aim.active || (e && e.pointerId!==aim.id)) return; aim.active=false; aim.id=null; try{ aimR.releasePointerCapture(e.pointerId);}catch{} }
    aimR.addEventListener('pointerup', endAim); aimR.addEventListener('pointercancel', endAim);
    btnFire.addEventListener('pointerdown', (e)=>{ if(!isMobileLike) return; e.preventDefault(); mouseDown=true; btnFire.classList.add('on'); });
    btnFire.addEventListener('pointerup', (e)=>{ if(!isMobileLike) return; e.preventDefault(); mouseDown=false; btnFire.classList.remove('on'); });
    btnFire.addEventListener('pointercancel', ()=>{ mouseDown=false; btnFire.classList.remove('on'); });
    btnPickup.addEventListener('pointerdown', (e)=>{ if(!isMobileLike) return; e.preventDefault(); pickupPressed=true; setTimeout(()=> pickupPressed=false, 120); });
    btnSprint.addEventListener('pointerdown', (e)=>{ if(!isMobileLike) return; e.preventDefault(); sprintPressed=true; btnSprint.classList.add('on'); });
    btnSprint.addEventListener('pointerup', (e)=>{ if(!isMobileLike) return; e.preventDefault(); sprintPressed=false; btnSprint.classList.remove('on'); });
    btnSprint.addEventListener('pointercancel', ()=>{ sprintPressed=false; btnSprint.classList.remove('on'); });

    // === Weapons & Shooting ===
    const raycaster = new THREE.Raycaster(); raycaster.far = 80;
    const impactMats = { yellow: new THREE.MeshBasicMaterial({ color:0xfff09a }) };
    const tempV = new THREE.Vector3(); const tempQ = new THREE.Quaternion(); const hitSparks = [];
    function addSpark(pt){ const s = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), impactMats.yellow); s.position.copy(pt); s.userData.ttl = 0.08; scene.add(s); hitSparks.push(s); }
    const weapons = { pistol:{ name:'Pistol', fireRate:4, damage:50, spread:0, pellets:1 }, smg:{ name:'SMG', fireRate:9, damage:26, spread:0.01, pellets:1 }, shotgun:{ name:'Shotgun', fireRate:1.6, damage:13, spread:0.035, pellets:7 } };
    let currentWeapon = weapons.pistol; weaponEl.textContent = currentWeapon.name; let shootCooldown = 0;
    let audioCtx = null;
    function initAudio(){ if(!audioCtx){ const AC = window.AudioContext || window.webkitAudioContext; if(AC) audioCtx = new AC(); } }
    function playShoot(){ if(!audioCtx) return; const now = audioCtx.currentTime; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='square'; o.frequency.setValueAtTime(380, now); o.frequency.exponentialRampToValueAtTime(120, now+0.08); g.gain.setValueAtTime(0.001, now); g.gain.exponentialRampToValueAtTime(0.4, now+0.005); g.gain.exponentialRampToValueAtTime(0.0001, now+0.12); o.connect(g).connect(audioCtx.destination); o.start(now); o.stop(now+0.13); }
    function screenFlash(){ centerFlash.style.opacity = 1; requestAnimationFrame(()=> centerFlash.style.opacity = 0); }
    function randInCone(dir, spread){ const angle = spread * (Math.random()*2-1), angle2 = spread * (Math.random()*2-1); const qx = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), angle); const qy = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), angle2); tempQ.copy(qx).multiply(qy); return dir.clone().applyQuaternion(tempQ).normalize(); }

    function fire(){
        if(state!=='playing' || shootCooldown>0) return;
        shootCooldown = 1 / currentWeapon.fireRate;
        
        // --- EFEK RECOIL & BLOOM ---
        recoil += 0.03; // Besarnya hentakan ke atas
        const crosshairEl = document.getElementById('crosshair');
        crosshairEl.classList.add('recoiling');
        setTimeout(() => crosshairEl.classList.remove('recoiling'), 100);

        screenFlash(); playShoot();
        const camPos = camera.getWorldPosition(new THREE.Vector3());
        const dir = camera.getWorldDirection(new THREE.Vector3());
        for(let i=0; i<currentWeapon.pellets; i++){
            const d = currentWeapon.spread ? randInCone(dir, currentWeapon.spread) : dir;
            raycaster.set(camPos, d);
            const hits = raycaster.intersectObjects(zombieHitMeshes, false);
            if(hits.length){
                const h = hits[0]; addSpark(h.point);
                let obj = h.object;
                while(obj && !obj.userData.isZombie){ obj = obj.parent; }
                if(obj){
                    obj.userData.health -= currentWeapon.damage;
                    obj.userData.flinchTime = 0.15; // Picu flinch
                    if(obj.userData.health<=0) killZombie(obj);
                }
            }
        }
    }

    // === Enemies ===
    const zombies = [], zombieHitMeshes = [];
    const zBodyMat = new THREE.MeshStandardMaterial({ color:0x557a5a, roughness:1 });
    const zHeadMat = new THREE.MeshStandardMaterial({ color:0x9ccfaa, roughness:.9 });

    function createZombieAt(x,z){
        const g = new THREE.Group();
        g.userData = { isZombie:true, health:100, speed:0.65, biteCooldown:0, flinchTime: 0, originalY: 1.25 };
        
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.32,0.38,1.15,8), zBodyMat);
        body.position.y=0.6;
        body.castShadow = true;

        const head = new THREE.Mesh(new THREE.SphereGeometry(0.25,12,12), zHeadMat);
        head.position.y=1.25;
        head.castShadow = true;

        const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.05,8,8), new THREE.MeshBasicMaterial({color:0x111111}));
        const eyeR = eyeL.clone();
        eyeL.position.set(-0.08,1.27,0.22);
        eyeR.position.set(0.08,1.27,0.22);

        g.add(body, head, eyeL, eyeR);
        g.position.set(x,0,z);
        scene.add(g);
        zombies.push(g);
        zombieHitMeshes.push(body, head, eyeL, eyeR);
        return g;
    }
    function spawnZombie(){ const radius = worldSize*0.9, ang = Math.random()*Math.PI*2; const x = Math.cos(ang)*radius, z = Math.sin(ang)*radius; const g = createZombieAt(x,z); g.userData.speed *= (0.9 + Math.random()*0.3); }
    function killZombie(g){ if(!g) return; g.traverse(o=>{ const i=zombieHitMeshes.indexOf(o); if(i!==-1) zombieHitMeshes.splice(i,1); }); scene.remove(g); const i=zombies.indexOf(g); if(i!==-1) zombies.splice(i,1); kills++; scoreEl.textContent = `Kill: ${kills}`; }

    // === Pickups ===
    const pickups = [];
    const crateMat = new THREE.MeshStandardMaterial({ color:0xf59e0b, roughness:.8 });
    const crateBandMat = new THREE.MeshStandardMaterial({ color:0x3f3f46, roughness:.9 });
    function createCrate(type, x, z){ const g = new THREE.Group(); g.userData = { isCrate:true, type }; const box = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.6,0.8), crateMat); const band1 = new THREE.Mesh(new THREE.BoxGeometry(0.82,0.08,0.12), crateBandMat); band1.position.y=0.18; const band2 = band1.clone(); band2.position.z=0.2; const band3 = band1.clone(); band3.position.z=-0.2; const label = createTextSprite(type.toUpperCase()); label.position.set(0,0.5,0); const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05,2.2,10), new THREE.MeshStandardMaterial({ color:0xffff66, emissive:0x333300, roughness:.6 })); pole.position.y=1.4; g.add(box, band1, band2, band3, label, pole); g.position.set(x,0,z); scene.add(g); pickups.push(g); g.traverse(o => { if(o.isMesh) o.castShadow = true; }); return g; }
    function createApple(x, z){ const g = new THREE.Group(); g.userData = { isApple:true, type:'apple', heal:20 }; const fruit = new THREE.Mesh(new THREE.SphereGeometry(0.22,16,16), new THREE.MeshStandardMaterial({ color:0xff3b3b, roughness:.7 })); fruit.position.y=0.25; const leaf = new THREE.Mesh(new THREE.ConeGeometry(0.08,0.18,8), new THREE.MeshStandardMaterial({ color:0x3ba74a })); leaf.position.set(0.08,0.45,0); leaf.rotation.z=-0.6; const label = createTextSprite('+20 HP'); label.position.set(0,0.8,0); g.add(fruit, leaf, label); g.position.set(x,0,z); scene.add(g); pickups.push(g); g.traverse(o => { if(o.isMesh) o.castShadow = true; }); return g; }
    function createTextSprite(text){ const cnv=document.createElement('canvas'); const size=256; cnv.width=cnv.height=size; const ctx=cnv.getContext('2d'); ctx.fillStyle='rgba(0,0,0,0)'; ctx.fillRect(0,0,size,size); ctx.fillStyle='#ffffff'; ctx.font='bold 42px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.strokeStyle='rgba(0,0,0,.6)'; ctx.lineWidth=6; ctx.strokeText(text, size/2, size/2); ctx.fillText(text, size/2, size/2); const tex=new THREE.CanvasTexture(cnv); tex.colorSpace=THREE.SRGBColorSpace; tex.needsUpdate=true; const mat=new THREE.SpriteMaterial({ map: tex, depthWrite:false }); const spr=new THREE.Sprite(mat); spr.scale.set(1.2,0.5,1); return spr; }
    function showBanner(msg){ const banner=document.getElementById('banner'); if(!banner) return; banner.textContent=msg; banner.classList.add('show'); clearTimeout(showBanner._t); showBanner._t=setTimeout(()=> banner.classList.remove('show'), 1600); }
    function tryPickup(){ const p=camera.position; for(let i=pickups.length-1;i>=0;i--){ const c=pickups[i]; if(!c||!c.position){ pickups.splice(i,1); continue; } const dx=c.position.x-p.x, dz=c.position.z-p.z; const hdist=Math.hypot(dx,dz); if(hdist<1.8){ const t=c.userData.type; if(t==='smg'||t==='shotgun'){ currentWeapon=weapons[t]; weaponEl.textContent=currentWeapon.name; showBanner(`Dapat ${currentWeapon.name}!`);} else if(t==='apple'){ const heal=c.userData.heal||20; health=Math.min(100, health+heal); setHealthUI(); showBanner(`HP +${heal}`);} scene.remove(c); pickups.splice(i,1); break; } } }

    // === Game state / loop ===
    let time = 0, kills = 0, health = 100; let spawnTimer = 0, crateTimer = 0, appleTimer = 8; const baseSpeed = 7.2, sprintMult = 2.0; let spdBonusCache = 0;
    function resetGame(){ zombies.slice().forEach(killZombie); pickups.forEach(c=> scene.remove(c)); pickups.length=0; camera.position.set(0, playerHeight, 0); yaw=0; pitch=0; health=100; setHealthUI(); kills=0; scoreEl.textContent='Kill: 0'; currentWeapon=weapons.pistol; weaponEl.textContent=currentWeapon.name; time=0; spawnTimer=0; crateTimer=0; appleTimer=8; shootCooldown=0; }
    function setHealthUI(){ const pct=Math.max(0, Math.min(1, health/100)); healthFill.style.transform=`scaleX(${pct})`; }
    function startGame(){ resetGame(); state='playing'; startUI.style.display='none'; initAudio(); }
    function endGame(){ state='over'; gameover.style.display='flex'; statsEl.textContent=`Anda bertahan ${Math.round(time)} detik · ${kills} kill`; }
    startBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('click', ()=>{ gameover.style.display='none'; startUI.style.display='flex'; });
    addEventListener('resize', ()=>{ W=innerWidth; H=innerHeight; renderer.setSize(W,H); camera.aspect=W/H; camera.updateProjectionMatrix(); });

    function zombieAI(dt){
        const p=camera.position;
        for(let i=zombies.length-1;i>=0;i--){
            const z=zombies[i];
            if(!z||!z.position) continue;

            // Efek Head Bob
            const head = z.children[1]; // Asumsi kepala adalah anak kedua
            if(head) head.position.y = z.userData.originalY + Math.sin(time * 8 + z.id) * 0.08;

            // Logika Flinch
            if(z.userData.flinchTime > 0) {
                z.userData.flinchTime -= dt;
                continue; // Lewati pergerakan jika sedang flinch
            }

            tempV.set(p.x - z.position.x, 0, p.z - z.position.z);
            const dist=tempV.length();
            if(dist>0.0001) tempV.multiplyScalar(1/dist);
            z.position.addScaledVector(tempV, (z.userData.speed+spdBonusCache)*dt);
            z.rotation.y=Math.atan2(p.x - z.position.x, p.z - z.position.z);
            if(dist<1.15){
                z.userData.biteCooldown -= dt;
                if(z.userData.biteCooldown<=0){
                    z.userData.biteCooldown=0.45;
                    health -= 8; if(health<0) health=0;
                    setHealthUI();
                    if(health<=0){ endGame(); break; }
                }
            }
        }
    }

    let last = performance.now();
    function tick(){
        const now=performance.now();
        const dt=Math.min(0.05, (now-last)/1000);
        last=now;
        if(state==='playing'){
            time += dt;
            shootCooldown -= dt;
            if(shootCooldown<0) shootCooldown=0;
            if(mouseDown) fire();
            spdBonusCache=Math.min(1.5, 0.0025*time);
            spawnTimer -= dt;
            if(spawnTimer<=0){ spawnZombie(); const base=2.4, minI=0.45; const ramp=Math.max(minI, base - time*0.02); spawnTimer=ramp; zombies.forEach(z=>{ if(z?.userData) z.userData.speed=Math.min(2.2,(z.userData.speed||0)+0.005); }); }
            crateTimer -= dt;
            if(crateTimer<=0){ if(pickups.filter(p=>p&&p.userData&&p.userData.isCrate).length<2){ const t=Math.random()<0.5?'smg':'shotgun'; const r=10+Math.random()*(worldSize-14); const ang=Math.random()*Math.PI*2; createCrate(t, Math.cos(ang)*r, Math.sin(ang)*r); } crateTimer=14+Math.random()*10; }
            appleTimer -= dt;
            if(appleTimer<=0){ if(pickups.filter(p=>p&&p.userData&&p.userData.isApple).length<3){ const r=6+Math.random()*16; const ang=Math.random()*Math.PI*2; createApple(camera.position.x+Math.cos(ang)*r, camera.position.z+Math.sin(ang)*r); } appleTimer=10+Math.random()*8; }

            // Movement
            const speed = baseSpeed * ((keys.shift||sprintPressed)? sprintMult:1);
            const dir2 = new THREE.Vector2(0,0);
            if(isMobileLike){ dir2.x += joy.x; dir2.y += joy.y; } else { if(keys.w) dir2.y += 1; if(keys.s) dir2.y -= 1; if(keys.a) dir2.x -= 1; if(keys.d) dir2.x += 1; }
            if(dir2.lengthSq()>0) dir2.normalize();
            const forward = camera.getWorldDirection(new THREE.Vector3()); forward.y=0; if(forward.lengthSq()>0) forward.normalize();
            const right = new THREE.Vector3(-forward.z, 0, forward.x);
            const moveDir = new THREE.Vector3().addScaledVector(forward, dir2.y).addScaledVector(right, dir2.x);
            if(moveDir.lengthSq()>0) moveDir.normalize();
            camera.position.addScaledVector(moveDir, speed*dt);
            camera.position.x = Math.max(-worldSize+1, Math.min(worldSize-1, camera.position.x));
            camera.position.z = Math.max(-worldSize+1, Math.min(worldSize-1, camera.position.z));
            camera.position.y = playerHeight;
            
            // Pulihkan recoil secara perlahan
            recoil *= 0.85; // Makin kecil angkanya, makin cepat pulih
            if(recoil < 0.001) recoil = 0;
            // Terapkan rotasi kamera + recoil
            camera.quaternion.setFromEuler(new THREE.Euler(pitch - recoil, yaw, 0, 'YXZ'));

            if(keys.r || pickupPressed) { tryPickup(); pickupPressed=false; }
            zombieAI(dt);
            for(let i=hitSparks.length-1;i>=0;i--){ const s=hitSparks[i]; if(!s){ hitSparks.splice(i,1); continue; } s.userData.ttl -= dt; s.scale.multiplyScalar(0.9); if(s.userData.ttl<=0){ scene.remove(s); hitSparks.splice(i,1); } }
        }
        renderer.render(scene, camera);
        requestAnimationFrame(tick);
    }
    tick();

    createCrate('smg', 3, -3); createCrate('shotgun', -3, 3); createApple(2, -1);
    addEventListener('blur', ()=>{ mouseDown=false; mouseIn=false; sprintPressed=false; });

  })();
  </script>
</body>
</html>
